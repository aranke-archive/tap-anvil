# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"""

A `Cast` holds configuration for a single PDF template. It defines the
location of boxes on PDF pages, and the type of each box (e.g. date, phone
number, etc.).

`Cast` objects are used by several API features:

* The [PDF filling endpoint](/docs/api/fill-pdf)
* Etch signature packets: see the [Etch e-sign guide](/docs/api/e-signatures) for more info
* Workflows: see the [Workflow API guide](/docs/api/workflows) for more info
"""
type Cast {
    archivedAt: Date
    config(
        "Only retrieve the specific keys provided."
        onlyKeys: [String]
    ): JSON
    createdAt: Date
    eid: String
    "Example data payload to fill this PDF. Shown on the \"API Info\" tab for this template"
    exampleData: JSON
    "A digestable array of objects with all the details about all fields in this PDF, sorted by page, top to bottom, left to right. Shown on the \"API Info\" tab for this template"
    fieldInfo: JSON
    hasBeenPublished: Boolean
    hasUnpublishedChanges: Boolean
    id: Int!
    isLatestVersion: Boolean
    isPublishedVersion: Boolean
    "`true` when this `Cast` was created as a template. Template casts show up in the `PDF Templates` page on your dashboard."
    isTemplate: Boolean
    latestDraftVersionNumber: Int
    "The internal location of this file in cloud storage"
    location: String
    "The file name"
    name: String
    organization: Organization
    "If this `Cast` was originally copied from another `Cast`, this will be the original `Cast`."
    parentCast: Cast
    publishedAt: Date
    "Current published version number of this Cast"
    publishedNumber: Int
    publishedVersionId: Int
    publishedVersionNumber: Int
    publishedVersions(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): CastVersionPage
    "The title shown in the UI"
    title: String
    "The file's mimetype. e.g. `application/pdf`"
    type: String
    updatedAt: Date
    versionId: Int
    "Current version number of this Cast"
    versionNumber: Int
    versions(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): CastVersionPage
}

type CastPage {
    "The actual records for the requested page"
    items: [Cast]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type CastVersion {
    config: JSON
    createdAt: Date
    eid: String!
    id: Int!
    location: String
    name: String
    number: Int
    publishUpdatedAt: Date
    publishedAt: Date
    publishedDescription: String
    publishedNumber: Int
    publishedTitle: String
    publishingUser: User
    title: String
    type: String
    updatedAt: Date
    updatedColumns: [String]
    user: User
}

type CastVersionPage {
    "The actual records for the requested page"
    items: [CastVersion]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"""

A collection of all the final files generated with data from a `WeldData` or
`EtchPacket`. When your users download a zip file of PDFs, that final
collection of filled, generated, uploaded, and signed files is specified by
the `DocumentGroup`. A `DocumentGroup` will be connected to either a
`WeldData` or a `EtchPacket`, never both. A `DocumentGroup` will only
exist on these objects if it has been sent out for signature.
"""
type DocumentGroup {
    "Timestamp of when all Signers have finished signing or when all forms have been filled when no signers."
    completedAt: Date
    createdAt: Date
    currentRoutingStep: Int
    "The URL to download all documents as a zip file"
    downloadZipURL: String
    eid: String
    "The parent `EtchPacket`. This will only exist for DocumentGroups created as part of an Etch signature packet."
    etchPacket: EtchPacket
    "A file listing of all files in the `DocumentGroup`"
    files: [JSON]
    finishPageConfig: JSON
    id: Int!
    "Possible values: `etch` or `docusign`"
    provider: String
    providerConfig: JSON
    signaturePageConfig: JSON
    signers: [Signer]
    "Possible values: `sent`, `delivered`, `partial`, `declined`, `voided`, `completed`"
    status: String
    updatedAt: Date
    "The parent `WeldData`. This will only exist for DocumentGroups created by a Workflow."
    weldData: WeldData
}

type DocumentGroupPage {
    "The actual records for the requested page"
    items: [DocumentGroup]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"""

Represents a single action taken by a user during the signing process. For
example, an `EtchLog` object will be created when a user signs, downloads
a file, voids the packet, etc.

All actions with a short description:

```md
accessed: Viewed
archived: Archived
completed: Signed & Completed
created: Created
download-csv-all: Downloaded CSV
download-csv-individual-file: Downloaded CSV File
download-file-individual: Downloaded File
download-files-zip: Downloaded Zip
emailed-completed: Emailed
emailed: Emailed
locked: Locked
pin-code-changed: Changed PIN
pin-code-failed: Access Failed
pin-code-set: Set PIN
pin-code-unset: Unset PIN
pin-code-verified: Access Verified
saved-form: Saved form
signed: Signed
unarchived: Unarchived
unlocked: Unlocked
upload-file-accessed: Accessed file
upload-file: Uploaded
voided: Voided
```
"""
type EtchLog {
    "The action taken."
    action: String
    createdAt: Date
    eid: String
    "String id, often a filename, of any file related to the action taken."
    fileId: String
    "Location of the user taking the action."
    formattedLocation: String
    id: Int!
    "Any action-specific information."
    metadata: JSON
    "The Signer who took the action, if applicable."
    signer: Signer
    "The Anvil `User` who took this action, if applicable."
    user: User
}

"An `EtchPacket` represents a signature packet. `EtchPackets` packets allow you to gather signatures from multiple signers on a collection of PDFs filled with your data (see `payload`), and uploads such as images. See the [e-signature guide](/docs/api/e-signatures) for usage."
type EtchPacket {
    archivedAt: Date
    "`true` when `payload` contains data that will fill PDFs"
    containsFillData: Boolean
    createdAt: Date
    "URL to this `EtchPacket` in the dashboard. Any users in your organization can view this URL."
    detailsURL: String
    "A `DocumentGroup` contains the documents after they have been filled and sent out for signature. The `DocumentGroup` will only exist here when `status != 'draft'`, i.e when documents have been sent out for signature. See the `DocumentGroup`'s `status` for lifecycle information."
    documentGroup: DocumentGroup
    eid: String
    "An array of actions during the signing process. Details actions when files are signed, downloaded, etc."
    etchLogEvents: [EtchLog]
    "The `EtchTemplate` holds configuration for signers and files in the packet. Each `EtchPacket` will have an `EtchTemplate`."
    etchTemplate: EtchTemplate
    id: Int!
    isFree: Boolean @deprecated(reason: "Use etchTemplate.isFree instead")
    "`true` when it is a test packet. You will not be charged for test packets. Filled and signed files will be watermarked."
    isTest: Boolean
    "The name shown in the UI."
    name: String
    numberRemainingSigners: Int
    organization: Organization
    "Data specified to fill PDFs in the packet."
    payload: JSON
    "Possible values: `draft`, `sent`, `delivered`, `partial`, `declined`, `voided`, `completed`."
    status: String
    updatedAt: Date
    "Uploaded files like images included in the packet."
    userUploads: [UserUpload]
    "An array of webhook notification calls to your server related to this `EtchPacket`. Get the status codes, response times, and retry information from each `WebhookLog`."
    webhookLogs: [WebhookLog]
    "The specific webhook notification URL for this `EtchPacket`. We will POST to this URL when users take various actions."
    webhookURL: String
}

type EtchPacketPage {
    "The actual records for the requested page"
    items: [EtchPacket]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"An `EtchTemplate` holds configuration for a signature packet. You should not need to interact directly with an `EtchTemplate` very much. See the [e-signature guide](/docs/api/e-signatures) for more info on sending documents out for signatures."
type EtchTemplate {
    "All `Cast` objects (fillable pdfs) included in this template."
    casts: [Cast]
    config: JSON
    createdAt: Date
    eid: String
    "An array of `EtchPackets` created from this template. At this time, this will be a 1-to-1 relationship."
    etchPackets: [EtchPacket]
    id: Int!
    isFree: Boolean
    isRepeatable: Boolean
    name: String
    organization: Organization
    updatedAt: Date
    userUploads: [UserUpload]
}

type File {
    encoding: String!
    key: String!
    mimetype: String!
    name: String!
    src: String!
}

"""

A `Forge` holds configuration for a single webform. A `Forge` defines a
webform's fields, the page fields are on, their types, webform logic, etc.
Each Forge will be a member of only one `Weld` (Workflow).

See our [Workflow API guide](/docs/api/workflows) for more info.
"""
type Forge {
    archivedAt: Date
    config(onlyKeys: [String]): JSON
    createdAt: Date
    eid: String
    "Example payload to fill this webform. Shown on the \"API information\" page for this webform's Workflow."
    examplePayload: JSON
    "A list of objects describing all the fields in this webform. The response is a more digestable way to get all the fields than digging in `config`."
    fieldInfo: JSON
    hasBeenPublished: Boolean
    hasUnpublishedChanges: Boolean
    id: Int!
    isLatestVersion: Boolean
    isPublishedVersion: Boolean
    "Is this forge required to complete the Workflow?"
    isRequired: Boolean
    latestDraftVersionNumber: Int
    name: String
    organization: Organization
    publishedAt: Date
    "Current published version number of this Forge"
    publishedNumber: Int
    "The slug of the currently published version"
    publishedSlug: String
    publishedVersionId: Int
    publishedVersionNumber: Int
    publishedVersions(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): ForgeVersionPage
    slug: String
    updatedAt: Date
    userUploads: [UserUpload]
    versionId: Int
    "Current version number of this Forge"
    versionNumber: Int
    versions(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): ForgeVersionPage
    weld: Weld
}

type ForgeMap {
    config: JSON
    createdAt: Date
    eid: String
    forgeA: Forge
    forgeB: Forge
    id: Int!
    updatedAt: Date
}

type ForgePage {
    "The actual records for the requested page"
    items: [Forge]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type ForgeVersion {
    config: JSON
    createdAt: Date
    eid: String!
    id: Int!
    name: String
    number: Int
    publishUpdatedAt: Date
    publishedAt: Date
    publishedDescription: String
    publishedNumber: Int
    publishedTitle: String
    publishingUser: User
    slug: String
    updatedAt: Date
    updatedColumns: [String]
    user: User
}

type ForgeVersionPage {
    "The actual records for the requested page"
    items: [ForgeVersion]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type Invoice {
    endDate: Date
    startDate: Date
    totalAmount: Float
}

type InvoiceBucketItem {
    includedUnits: Int
    unitType: String
    usedUnits: Int
}

type InvoiceUnitItem {
    baseUnits: Int
    totalAmount: Float
    unitAmount: Float
    unitType: String
    usedUnits: Int
}

type Mutation {
    """

    Create a `Cast` with the specified properties. This will require you to publish the `Cast`
    via the [`publishCast`]({{Mutations.publishCast}}) mutation before it will go live.
    """
    createCast(file: Upload!, isTemplate: Boolean = true, organizationEid: String, title: String): Cast
    """

    Create an e-signature packet. See the
    [Etch e-sign guide](/docs/api/e-signatures) for usage information.
    """
    createEtchPacket(
        "Set to `true` to save uploaded PDFs to your PDF templates."
        createCastTemplatesFromUploads: Boolean,
        data: JSON,
        duplicateCasts: Boolean = false,
        """

        Enable all, none, or specific emails for this packet. When enabled, an
        email type will adhere to the organization settings for that email type.
        For example, when `signerViewAdmin` is enabled, an email will only be
        sent to organization members specified in the organization settings.

        Possible values: `true`, `false`, or an array of strings with any of
        the following `'signerViewAdmin'`, `'signerCompleteAdmin'`, or
        `'etchCompleteAdmin'`.

        The default is `false`.
        """
        enableEmails: JSON,
        files: [EtchFile!],
        isDraft: Boolean,
        isTest: Boolean,
        """

        When enabled, merges all PDFs before users sign. All signers will sign
        one (potentially large) PDF.
        """
        mergePDFs: Boolean,
        name: String,
        organizationEid: String,
        """

        Overrides the replyTo header on emails sent to signers.
        By default, this will be the support email listed in your organization settings.
        """
        replyToEmail: String,
        """

        Overrides the replyTo header on emails sent to signers.
        By default, this will be your organization name.
        """
        replyToName: String,
        "Customizes the email body on signer emails"
        signatureEmailBody: String,
        "Customizes the email subject on signer emails"
        signatureEmailSubject: String,
        signaturePageOptions: JSON,
        signatureProvider: String,
        signers: [JSON!],
        webhookURL: String
    ): EtchPacket
    """

    Create a `Forge` with the specified properties. This will require you to publish the `Weld`
    via the [`publishWeld`]({{Mutations.publishWeld}}) mutation before it will go live with the Workflow.
    """
    createForge(castEid: String, castFieldIds: JSON, config: JSON, name: String!, slug: String!, weldEid: String!): Forge
    createSubmission(forgeEid: String!, weldDataEid: String!): Submission
    createWebhook(organizationEid: String, organizationSlug: String, url: String): Organization
    """

    Create a `Weld` with the specified properties. This will require you to publish the `Weld`
    via the [`publishWeld`]({{Mutations.publishWeld}}) mutation before it will go live.
    """
    createWeld(castEid: String, config: JSON, draftStep: String, name: String!, organizationEid: String!, slug: String, visibility: String): Weld
    createWeldData(isTest: Boolean = false, webhookURL: String, weldDataGroupEid: String, weldEid: String!): WeldData
    destroySubmission(eid: String!): Boolean
    disconnectDocusign(organizationSlug: String!): Organization
    duplicateCast(eid: String!, name: String, organizationEid: String!, title: String): Cast
    duplicateWeld(eid: String!, name: String, organizationEid: String!, slug: String, versionNumber: Int, visibility: String): Weld
    """

    Expires all valid `SignerTokens` for a specific `Signer`. Signers who
    visit links with expired tokens will be shown a "Token Expired" error, or
    will be [redirected to your
    service](/docs/api/e-signatures#handling-signing-errors) if there is a
    `redirectURL` set on the signer.

    If the `Signer` has already completed signing, this mutation will throw an
    error. If you would like the `Signer` to be able to sign again, email
    signers will need to be notified via `sendEtchPacket`, and embedded
    signers will need a new signing link generated by `generateEtchSignURL`.
    """
    expireSignerTokens(signerEid: String!): Signer
    """

    Submits data to a Workflow's webform (a `Forge`). You can use this
    mutation to start a Workflow with data from your system and submit data to
    an _existing_ `Submission`.

    See the [Workflow API guide](/docs/api/workflows) for more information on
    usage scenarios.
    """
    forgeSubmit(
        complete: Boolean,
        currentStep: Int,
        enforcePayloadValidOnCreate: Boolean = true,
        errorType: String,
        forgeEid: String!,
        groupArrayId: String,
        groupArrayIndex: Int,
        isTest: Boolean = false,
        """

        A `{ key: value }` object where `key` is the id or field alias of the
        webform (`Forge`) field, and value is the data you'd like to send.

        Data is additive: you only need to submit data you wish to update.
        """
        payload: JSON!,
        submissionEid: String,
        timezone: String,
        webhookURL: String,
        weldDataEid: String
    ): Submission
    """

    Generate a signing URL for embedded signers. See the
    [e-sign API guide on embedding signers](/docs/api/e-signatures#controlling-the-signature-process-with-embedded-signers)
    for more info.
    """
    generateEtchSignURL(
        "Your id for the person signing: a way to trace this signer back to a user in your system."
        clientUserId: String!,
        signerEid: String!
    ): String
    """

    Publish a `Cast` by updating the `Cast` with all un-published changes.

    This is required to have any changes from an [`updateCast`]({{Mutations.updateCast}}) take effect.
    """
    publishCast(
        description: String,
        eid: String,
        title: String,
        """

        Optionally specify a specific version to publish. If omitted, the latest draft version
        will be used.
        """
        versionNumber: Int
    ): Cast
    """

    Publish a `Weld` by updating the `Weld` with all un-published changes.

    This is required to have any changes from an [`updateWeld`]({{Mutations.updateWeld}}) take effect.
    """
    publishWeld(
        description: String,
        eid: String,
        title: String,
        """

        Optionally specify a specific version to publish. If omitted, the latest draft version
        will be used.
        """
        versionNumber: Int
    ): Weld
    removeEtchPacket(eid: String!): Boolean
    removeWebhook(eid: String!): Organization
    removeWeldData(eid: String!): Boolean
    retryWebhookLog(eid: String!): WebhookLog
    """

    This will move a `draft` `EtchPacket` into sent mode (`status` ==
    `sent`). If the first signer is an email signer, this will kick off an
    email, with a link to sign their portion of the packet.

    You can call this mutation after a packet is sent to "resend" signature
    emails to your email signers. For example, you can send a new email via
    `sendEtchPacket` if they lose the email, or if they have an email with an
    expired token. This mutation will always email the first signer who has not
    yet signed.

    When your signers are set up as `embedded` signers, they will _not_ be
    emailed. You must generate signing URLs via the
    [`generateEtchSignURL`]({{Mutations.generateEtchSignURL}}) mutation. See
    [our e-signature guide on embedded signers](/docs/api/e-signatures#controlling-the-signature-process-with-embedded-signers)
    for more info.
    """
    sendEtchPacket(eid: String!): EtchPacket
    skipSigner(signerEid: String!): Signer
    """

    Update a `Cast` with new properties. This will create a new `CastVersion` and:
    1. If this being used as a Template, it will require you to publish the `Cast` via
    the [`publishCast`]({{Mutations.publishCast}}) mutation
    before it will go live.
    2. If the `Cast` is part of a Workflow, it will require you to publish the `Weld` via
    the [`publishWeld`]({{Mutations.publishWeld}}) mutation
    """
    updateCast(autoPublish: Boolean, config: JSON, configFile: Upload, eid: String!, file: Upload, isArchived: Boolean, name: String, title: String, versionNumber: Int): Cast
    updateEtchFree(castFields: [JSON], etchTemplateEid: String!, fields: [JSON], isEditing: Boolean, name: String, ownerEmail: String, ownerName: String, signers: JSON, token: String!): EtchTemplate
    updateEtchPacket(eid: String!, isArchived: Boolean, name: String, payload: JSON, token: String, webhookURL: String): EtchPacket
    updateEtchTemplate(config: JSON, eid: String!, isRepeatable: Boolean, name: String): EtchTemplate
    """

    Update a `Forge` with new properties. This will create a new `ForgeVersion` and
    will require you to publish the `Weld` via the [`publishWeld`]({{Mutations.publishWeld}}) mutation
    before it will go live.
    """
    updateForge(config: JSON, configFile: Upload, eid: String!, isArchived: Boolean, isRequired: Boolean, name: String, organizationRole: String, slug: String, title: String, unauthenticatedAuthType: String, versionNumber: Int): Forge
    updateOrganization(billingEmail: String, config: JSON, defaultSourceId: String, etchCompleteEmailRecipients: JSON, invoiceDaysUntilDue: Int, isInternal: Boolean, isInvoiceOrg: Boolean, logo: Upload, name: String, organizationSlug: String!, signatureProvider: String, signerCompleteEmailRecipients: JSON, signerViewEmailRecipients: JSON, slug: String, ssoId: String, stripeCustomerId: String, supportEmail: String, trialExpiresIn: Int, usePDFFillingAPI: Boolean, useTestSignatureProvider: Boolean, weldCompleteEmailRecipients: JSON): Organization
    updateOrganizationUser(externalId: String, organizationEid: String!, role: String!, userEid: String!): Organization
    updateSubmission(eid: String!, isExcluded: Boolean): Submission
    updateWebhook(eid: String!, url: String): Organization
    """

    Update a `Weld` with new properties. This will create a new `WeldVersion` and
    will require you to publish the `Weld` via the [`publishWeld`]({{Mutations.publishWeld}}) mutation
    before it will go live.
    """
    updateWeld(autoPublish: Boolean, autoPublishDescription: String, autoPublishTitle: String, config: JSON, configFile: Upload, dataDisplayTitle: JSON, draftStep: String, eid: String!, entryButtonCopyLink: Boolean, entryButtonText: String, entryForgeId: Int, expireAfterDaysComplete: Int, expireAfterDaysStart: Int, expiresAt: String, isArchived: Boolean, lockedDescriptionExisting: String, lockedDescriptionNew: String, lockedTitleExisting: String, lockedTitleNew: String, mergePDFs: Boolean, name: String, planEid: String, signatureEmailBody: JSON, signatureEmailSubject: JSON, signatureProvider: String, slug: String, versionNumber: Int, visibility: String, weldCompleteEmailRecipients: JSON): Weld
    updateWeldData(eid: String!, isArchived: Boolean, isExpired: Boolean, isTest: Boolean, pin: String, webhookURL: String): WeldData
    voidDocumentGroup(eid: String, voidedReason: String!, weldDataEid: String): DocumentGroup
}

"An entity that encapsulates a set of Workflows, templates, users, etc."
type Organization {
    adminUsers: [User]
    availableSignatureProviderTypes: [String]
    "The email used for all billing related correspondence."
    billingEmail: String
    casts(isArchived: Boolean = false, isTemplate: Boolean): [Cast]
    childOrganizations: [Organization]
    config: JSON
    createdAt: Date
    currentInvoice: Invoice
    eid: String
    etchCompleteStats: JSON
    etchPackets(
        isArchived: Boolean = false,
        isTest: Boolean = false,
        "The requested number of rows per page"
        limit: Int = 5,
        "The requested page number"
        offset: Int = 1,
        status: [String]
    ): EtchPacketPage
    etchTemplates: [EtchTemplate]
    forgeMaps: [ForgeMap]
    forges(isArchived: Boolean = false): [Forge]
    id: Int!
    isInternal: Boolean
    isPersonal: Boolean
    isSubscribed: Boolean
    logo: JSON
    "URL to your logo. You can update this on your organization settings page."
    logoURL: String
    name: String
    organizationUserInvites: [OrganizationUserInvite]
    organizationUsers: [OrganizationUser]
    parentOrganization: Organization
    paymentMethods: [PaymentMethod]
    remainingEtchCompletions: JSON
    remainingSubmissions: JSON
    signatureProviderType: String
    slug: String
    subscribedPlanFeatures: JSON
    subscriptionActivity: JSON
    "Your organization's support email address. Used as the reply-to address for emails sent to your users by Anvil."
    supportEmail: String
    totalUsedUnits: Int
    updatedAt: Date
    useTestSignatureProvider: Boolean
    users: [User]
    webhook: Webhook
    webhookActions: [WebhookAction]
    webhookLogs(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): WebhookLogPage
    weldCompleteStats: JSON
    weldCompleteWebhookStats: JSON
    weldGroups: [WeldGroup]
    welds(
        "Set to `true` to search only within archived Welds"
        isArchived: Boolean = false,
        "Filter based on the visibility of the Weld"
        visibility: String = "live"
    ): [Weld]
}

type OrganizationPage {
    "The actual records for the requested page"
    items: [Organization]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type OrganizationUser {
    createdAt: Date
    "A place to store your external system's unique identifier for this User."
    externalId: String
    id: Int!
    organization: Organization
    "Role of this user within your org. Possible values: viewer, editor, billingAdmin, admin"
    role: String
    updatedAt: Date
    user: User
}

"""

An invite sent for a user to join your organization. Once accepted, an
`OrganizationUser` will be created.
"""
type OrganizationUserInvite {
    acceptedAt: Date
    createdAt: Date
    eid: String
    email: String
    "A place to store your external system's unique identifier for this User."
    externalId: String
    id: Int!
    name: String
    organization: Organization
    revokedAt: Date
    "Role of this user within your org. Possible values: viewer, editor, billingAdmin, admin"
    role: String
    updatedAt: Date
}

type PaymentMethod {
    expMonth: Int
    expYear: Int
    id: String!
    isDefault: Boolean
    last4: String
    providerName: String
    status: String
    type: String
}

type Query {
    """

    Fetch a single `Cast`. A `Cast` is a PDF Template. See our
    [terminology guide](/docs/api/getting-started#terminology) for more info.
    """
    cast(
        eid: String!,
        versionAsOf: Date,
        """

        Optional argument to request a specific version of the `Cast`. If not provided,
        the last ***published*** version will be returned, unless it has not been published
        in which case the latest ***draft*** version will be returned.

        Providing `-1` is a special value that will return the latest
        draft version of the `Cast`.
        """
        versionNumber: Int
    ): Cast
    """

    Fetches the currently logged in user. When used in an API context, this will
    return your API user. The `currentUser` query is useful to fetch objects
    in your organization. e.g. your `Organization`, its `Weld`s, etc.
    """
    currentUser: User
    """

    Fetch a single `EtchPacket`. An `EtchPacket` represents a signature
    packet containing PDFs, signers, signed documents. This is the result of
    `createEtchPacket`. See the
    [e-signature API guide](/docs/api/e-signatures) for more info.
    """
    etchPacket(eid: String!): EtchPacket
    """

    Fetch a single `Forge`. You must specify both the `organizationSlug` and
    `eidOrSlug` to fetch a `Forge` with this query.

    A `Forge` holds configuration for a single webform. A `Forge` defines a
    webform's fields, the page fields are on, their types, webform logic, etc.
    Each Forge will be a member of only one `Weld` (Workflow). See our
    [terminology guide](/docs/api/getting-started#terminology) for more info.

    A better way to fetch `Forge`s is via the `weld` query.
    For example:

    ```graphql
    weld (eid: weldEid) {
    forges {
    eid
    slug
    name
    }
    }
    ```
    """
    forge(
        eidOrSlug: String!,
        organizationSlug: String!,
        versionAsOf: Date,
        """

        Optional argument to request a specific version of the `Forge`. If not provided,
        the last ***published*** version will be returned, unless it has not been published
        in which case the latest ***draft*** version will be returned.

        All `Welds` and `Casts` that are related to this `Forge` will be returned
        in their state "as-of" the version requested for the `Forge`.

        Providing `-1` is a special value that will return the latest
        draft version of the `Forge`, but also the latest draft version of any related
        `Weld` and `Casts`.
        """
        versionNumber: Int
    ): Forge
    """

    Fetch a single `Organization`. You obviously will only be able to access
    organizations you are a part of.

    A better way to fetch this information is via the `currentUser` query.
    For example:

    ```graphql
    currentUser {
    organizations {
    eid
    slug
    name
    }
    }
    ```
    """
    organization(organizationSlug: String!): Organization
    """

    Fetches a single `Signer`.

    A better way to fetch signers is via a `DocumentGroup` object. For
    example, use the `etchPacket` or `weldData` query, then dig down to the
    signers in your query.
    """
    signer(eid: String!, token: String!): Signer
    """

    Fetches a single `Submission`. A `Submission` holds data submitted to a
    webform. See our
    [terminology guide](/docs/api/getting-started#terminology) for more info.

    A better way to fetch submissions is via the `weldData` query. For example:

    ```graphql
    weldData (eid: weldDataEid) {
    displayTitle
    submissions {
    eid
    resolvedPayload
    }
    }
    ```
    """
    submission(eid: String!, forceCreate: Boolean, forgeEidOrSlug: String!, organizationSlug: String!, timezone: String): Submission
    """

    Fetch a single `Weld`. This query is a good way to fetch all of a
    Workflow's submissions (`WeldData`s). See the `Weld`'s `weldDatas`
    resolver.

    Specify either the `Weld`'s `eid` _or_ both the `Weld`'s `slug` and
    the `Weld`'s `organizationSlug`.

    See the [Workflow API guide](/docs/api/workflows) for more information on
    query usage.
    """
    weld(
        eid: String,
        organizationSlug: String,
        slug: String,
        versionAsOf: Date,
        """

        Optional argument to request a specific version of the `Weld`. If not provided,
        the last ***published*** version will be returned, unless it has not been published
        in which case the latest ***draft*** version will be returned.

        All `Forges` and `Casts` that are related to this `Weld` will be returned
        in their state "as-of" the version requested for the `Weld`.

        Providing `-1` is a special value that will return the latest
        draft version of the `Weld`, but also the latest draft version of any related
        `Forges` and `Casts`.
        """
        versionNumber: Int
    ): Weld
    """

    Fetch a single `WeldData` (Workflow submission). If you need to fetch all
    `WeldData`s for a given `Weld`, see the `weld` query.

    See the [Workflow API guide](/docs/api/workflows) for more information on
    query usage.
    """
    weldData(eid: String!): WeldData
}

"""

Represents a single signer. See `Signer.status` to indicate where a signer
is in the signing process.
"""
type Signer {
    "The `Signer`'s user-specified id set on packet creation."
    aliasId: String
    "Timestamp when the `Signer` has finished signing."
    completedAt: Date
    createdAt: Date
    "A `DocumentGroup` references all signers and the documents after they have been filled and sent out for signature. See the `DocumentGroup`'s `status` for lifecycle information."
    documentGroup: DocumentGroup
    eid: String
    email: String
    "The URL the user will be redirected to when they finish signing."
    finishURL: String
    id: Int!
    name: String
    "Possible values: `etch` or `docusign`."
    provider: String
    "Numeric step in the signing process where this user signs. Signers are routed in sorted order."
    routingOrder: Int
    "Indicates the method by which the user signs. Possible values: `email`, `embedded`, or `in-person`."
    signActionType: String
    "Get all `SignerTokens` this signer has available. These can tell you when a signer's token will be expiring, which token was used for signing, etc."
    signerTokens: [SignerToken]
    "Possible values: `sent`, `viewed`, `delivered`, `voided`, `autoresponded`, `faxpending`, `created`, `skipped`, `declined`, `idCheckFailed`, `completed`"
    status: String
    "An associated `Submission`. This wil exist for signers who sign at the end of a Workflow."
    submission: Submission
    updatedAt: Date
    "A Anvil `User` associated with this signer."
    user: User
}

type SignerPage {
    "The actual records for the requested page"
    items: [Signer]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"""

Represents a token used to sign documents. See `Signer.signerTokens` to
fetch them.

We do not expose the token itself, but you can use this object to get an
idea of what tokens the signer has available, whether they are valid, and
their expiration dates (`validUntil`).
"""
type SignerToken {
    eid: String
    "`true` when this token was used to sign the `Signer`'s documents."
    hasSigned: Boolean
    id: Int!
    "Date when the token was invalidated if explicitly invalidated. If invalid due to expiration, use `validUntil`."
    invalidatedAt: Date
    "Date when the token was used to sign documents."
    signedAt: Date
    signer: Signer
    "Type of token issued. Tells you how the token was issued. Values: `api`, `sign-now`, `notify-signer`, `view`"
    type: String
    "`true` when this token is valid and can be used to sign."
    valid: Boolean
    "Date of token expiration."
    validUntil: Date
}

"""

An instance of a `Forge`. A `Submission` holds the data for one webform
submission on a particular `Forge`.

See our [Workflow API guide](/docs/api/workflows) for more info.
"""
type Submission {
    completedAt: Date
    completionPercentage: Float
    "URL to the next step in this webform."
    continueURL: String
    createdAt: Date
    currentStep: Int
    eid: String
    forge: Forge
    id: Int!
    isExcluded: Boolean
    "The raw payload"
    payload: JSON
    "The raw payload without types"
    payloadValue: JSON
    requestMeta: JSON
    "The payload resolved with field aliases and field information. If you need to fetch the submission payload, use this."
    resolvedPayload: JSON
    reviewData: JSON
    signer: Signer
    "Possible values: `created`, `in-progress`, `waiting-to-sign`, `user-signed-and-waiting`, `users-turn-to-sign-ui`, `users-turn-to-sign-email`, `someone-else-signed-and-waiting`, `completed`"
    status: String
    totalSteps: Int
    touchedByUser: Boolean
    updatedAt: Date
    user: User
    weldData: WeldData
}

type SubmissionPage {
    "The actual records for the requested page"
    items: [Submission]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type User {
    createdAt: Date
    eid: String
    email: String
    extra: JSON
    firstName: String
    id: Int!
    lastName: String
    name: String
    numSentEtchPackets: Int
    organizationUsers: [OrganizationUser]
    organizations: [Organization]
    preferences: UserPreferences!
    "What type of role the User has. Either `user` or `api`."
    role: String
    updatedAt: Date
    verifiedEmail: Boolean
}

type UserPage {
    "The actual records for the requested page"
    items: [User]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type UserPreferences {
    acceptedSignature: Boolean
    initials: String
    name: String
    require2FA: Boolean
}

type UserUpload {
    createdAt: Date
    eid: String
    etchPacket: EtchPacket
    forge: Forge
    id: Int!
    location: String
    metadata: JSON
    updatedAt: Date
    user: User
    weldData: WeldData
}

"""

A `Webhook` represents a webhook URL. Anvil will POST to webhook URLs on
specific actions. Both organization-wide and per-object webhook URLs are
represented by this object. See the [webhooks guide](/docs/api/webhooks) for
more information.
"""
type Webhook {
    createdAt: Date
    creationUser: User
    eid: String
    id: Int!
    organization: Organization
    "Prossible values: `active` or `inactive`."
    status: String
    "Use this token to make sure the request is from Anvil."
    token: String
    "Webhook URLs that accept notifications for any object will be `prod`. Per-object webhook URLs will have type `adhoc`."
    type: String
    updatedAt: Date
    "The URL Anvil will POST to."
    url: String
    webhookActions: [WebhookAction]
}

"""

A model that represents a subscription to actions on other objects in our system
that would trigger a [`Webhook`]({{Types.Webhook}}) call.
"""
type WebhookAction {
    action: String!
    config: JSON
    createdAt: Date!
    creationUser: User!
    eid: String!
    objectEid: String
    objectType: String
    updatedAt: Date!
    webhook: Webhook!
}

"""

A `WebhookLog` represents a single webhook call to your server. See the
[webhooks guide](/docs/api/webhooks) for more information.
"""
type WebhookLog {
    "The webhook action type, e.g. `signerComplete`."
    action: String
    createdAt: Date
    eid: String
    id: Int!
    "`true` when this call was considered an error. It will be an error when the status code is >= 400, or the request timed out."
    isError: Boolean
    "`true` when this call was a retry of a previous call."
    isRetry: Boolean
    "Time it took to complete the webhook request."
    millisecondsToFinish: Int
    objectEid: String
    objectMetadata: JSON
    organization: Organization
    "If this call was a retry, `originalWebhookLog` will be `WebhookLog` that was retried."
    originalWebhookLog: WebhookLog
    rootObjectType: String
    "Dashboard URL to the object that triggered the webhook event. e.g. it will link to a Workflow submission or an etch packet."
    rootObjectURL: String
    "The status code returned by your server for this call."
    statusCode: Int
}

type WebhookLogPage {
    "The actual records for the requested page"
    items: [WebhookLog]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"""

A Weld is a Workflow. It holds the configuration that combines one or more
`Forge` objects with zero or more `Cast` objects to create a Workflow.

See our [Workflow API guide](/docs/api/workflows) for more info.
"""
type Weld {
    archivedAt: Date
    availableSignatureProviderTypes: [String]
    casts: [Cast]
    "Config object specifying files output, signers, etc."
    config(
        "Only root level keys specified here will be returned. When omitted, all keys will be returned."
        onlyKeys: [String]
    ): JSON
    createdAt: Date
    draftStep: String
    eid: String
    expiresAt: Date
    forges(isArchived: Boolean = false): [Forge]
    hasBeenPublished: Boolean
    hasSigners: Boolean
    hasUnpublishedChanges: Boolean
    hasWeldDatas: Boolean
    id: Int!
    isLatestVersion: Boolean
    isPublishedVersion: Boolean
    isTest: Boolean
    latestDraftVersionNumber: Int
    name: String
    organization: Organization
    publishedAt: Date
    "Current published version number of this Weld"
    publishedNumber: Int
    "The slug of the currently published version"
    publishedSlug: String
    publishedVersionId: Int
    publishedVersionNumber: Int
    publishedVersions(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): WeldVersionPage
    remainingSubmissions: JSON
    signatureProviderType: String
    slug: String
    styleConfig: JSON
    testSignerCompleteWebhookPayload: JSON
    testWebhookPayload: JSON @deprecated(reason: "Use testWeldCompleteWebhookPayload instead")
    testWeldCompleteWebhookPayload: JSON
    title: String
    updatedAt: Date
    versionId: Int
    "Current version number of this Weld"
    versionNumber: Int
    versions(
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1
    ): WeldVersionPage
    visibility: String
    weldDataCounts: JSON
    "Fetch all the `Weld`'s `WeldData`s (Workflow submissions)"
    weldDatas(
        fromDate: Date,
        ignoreTest: Boolean = true,
        isArchived: Boolean = false,
        isTest: Boolean = false,
        "The requested number of rows per page"
        limit: Int = 5,
        "The requested page number"
        offset: Int = 1,
        simpleSearchTerm: String,
        statuses: [String],
        toDate: Date,
        touchedByUser: Boolean = true
    ): WeldDataPage
    weldGroups: [WeldGroup]
}

"""

An instance of a `Weld`. You can think of it as a "workflow submission".
A `WeldData` references `Submission`s for all the `Forge`s (webforms)
in the related `Weld` (workflow).

See our [workflow API guide](/docs/api/workflows) for more info.
"""
type WeldData {
    agents: JSON
    archivedAt: Date
    "How complete is this workflow submission. Will be a value between 0 and 1."
    completionPercentage: Float
    "URL to the next form to be filled by the user. Use this after `WeldData` creation to get the URL to the form that should be filled first."
    continueURL: String
    createdAt: Date
    "When a the data in any child `Submission` was last updated."
    dataUpdatedAt: Date
    "The title displayed in the UI."
    displayTitle: String
    "A `DocumentGroup` contains the documents after they have been filled and sent out for signature. The `DocumentGroup` will only exist here when that documents have been sent out for signature, or in the case of a workflow with no signers, when the workflow is completely finished. See the `DocumentGroup`'s `status` for lifecycle information."
    documentGroup: DocumentGroup
    eid: String
    "An array of actions during the signing process when using Anvil's Etch as the signature provider. These objects detail actions when files are signed, downloaded, etc."
    etchLogEvents: [EtchLog]
    "A file listing of all files excluded from the signing process."
    excludedFiles: [JSON]
    expiresAt: Date
    "A file listing of all files available in the `WeldData`. If there is a `DocumentGroup`, this will be equal to `DocumentGroup.files`."
    files: [JSON]
    forgesRequiringCompletion: [Forge]
    hasPin: Boolean
    hasSigners: Boolean
    id: Int!
    "`true` when all forms in the workflow have been filled. There may be signers who need to sign."
    isComplete: Boolean
    "`true` when status is `completed`: All forms have been filled, all signers have signed."
    isCompleteAndSigned: Boolean
    "This `WeldData` has expired, either by passing the `expiredAt` date, or by being locked."
    isExpired: Boolean
    "`true` when it is a test workflow submission. You will not be charged for signatures on test submissions, and they will not count toward your monthly completed workflows."
    isTest: Boolean
    nextSigner: Signer
    numberRemainingSigners: Int
    payloadCanBeUpdated: Boolean
    pin: String
    "Possible values: `created`, `in-progress`, `ready-to-sign`, `awaiting-signatures`, `declined`, `completed`"
    status: String
    "An array of all the underlying `Submission` objects holding data from each webform."
    submissions: [Submission]
    "When a column on the WeldData itself was updated."
    updatedAt: Date
    "An array of files uploaded by users during the webform filling process."
    userUploads: [UserUpload]
    "An array of webhook notification calls to your server related to this `WeldData`. Get the status codes, response times, and retry information from each `WebhookLog`."
    webhookLogs: [WebhookLog]
    "The specific webhook notification URL for this `WeldData`. We will POST to this URL when users take various actions."
    webhookURL: String
    "The workflow this `WeldData` is related to."
    weld: Weld
    weldDataGroup: WeldDataGroup
    "An array of actions taken during the form filling process."
    weldDataLogEvents: [WeldDataLog]
}

type WeldDataGroup {
    archivedAt: Date
    createdAt: Date
    dataUpdatedAt: Date
    eid: String
    id: Int!
    isTest: Boolean
    title: String
    updatedAt: Date
    weldDatas(isArchived: Boolean = false): [WeldData]
    weldGroup: WeldGroup
}

type WeldDataGroupPage {
    "The actual records for the requested page"
    items: [WeldDataGroup]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"""

Represents a single action taken by a user while filling a webform within a Workflow. For
example, a `WeldDataLog` object will be created when a user completes a webform, downloads
a file, voids the packet associated packet, etc.

All actions with a short description:

```md
accessed: Viewed
archived: Archived
completed: Completed Form
created: Created
download-csv-all: Downloaded
download-csv-individual-file: Downloaded
download-file-individual: Downloaded File
download-files-zip: Downloaded Zip
emailed-completed: Emailed
emailed: Emailed
locked: Locked
pin-code-changed: Changed PIN
pin-code-failed: Access Failed
pin-code-set: Set PIN
pin-code-unset: Unset PIN
pin-code-verified: Access Verified
saved-form: Saved form
signed: Signed
unarchived: Unarchived
unlocked: Unlocked
upload-file-accessed: Accessed file
upload-file: Uploaded
voided: Voided
```
"""
type WeldDataLog {
    "The action taken."
    action: String
    createdAt: Date
    eid: String
    "Location of the user taking the action."
    formattedLocation: String
    id: Int!
    "Any action-specific information."
    metadata: JSON
    submission: Submission
    "The Anvil `User` who took this action, if applicable."
    user: User
    weldData: WeldData
}

type WeldDataPage {
    "The actual records for the requested page"
    items: [WeldData]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type WeldGroup {
    createdAt: Date
    eid: String
    hasWeldDataGroups: Boolean
    id: Int!
    name: String
    organization: Organization
    slug: String
    updatedAt: Date
    weldDataGroups(
        ignoreTest: Boolean = true,
        isArchived: Boolean = false,
        isTest: Boolean = false,
        "The requested number of rows per page"
        limit: Int = 10,
        "The requested page number"
        offset: Int = 1,
        weldSlugFilter: [String]
    ): WeldDataGroupPage
    welds(isArchived: Boolean = false): [Weld]
}

type WeldPage {
    "The actual records for the requested page"
    items: [Weld]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

type WeldVersion {
    config: JSON
    createdAt: Date
    eid: String!
    id: Int!
    name: String
    number: Int
    publishUpdatedAt: Date
    publishedAt: Date
    publishedDescription: String
    publishedNumber: Int
    publishedTitle: String
    publishingUser: User
    slug: String
    updatedAt: Date
    updatedColumns: [String]
    user: User
}

type WeldVersionPage {
    "The actual records for the requested page"
    items: [WeldVersion]
    "The requested page number"
    page: Int
    "Total number of pages of results"
    pageCount: Int
    "The requested number of rows per page"
    pageSize: Int
    "Total number of rows found for the query before pagination"
    rowCount: Int
}

"Datetime value represented in `ISO8601`."
scalar Date

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"""

The `Upload` scalar type represents a file upload. This can be either
an object with `data`, `mimetype`, and `filename` keys, or multipart
request with a structure described by the
[GraphQL multipart requests specification](https://github.com/jaydenseric/graphql-multipart-request-spec).

While sending up an object structure described in the example is considerably
simpler than the multipart spec, we only support request payloads of up to 1MB.
Content-Type `application/json` requests with sizes over the 1MB size will
result in a `419 Request Too Large` response.

If your request is larger than 1MB, use a multipart request. A very basic
multipart GraphQL + `Upload` example using `curl`:

```sh
curl https://graphql.useanvil.com \ -F operations='[{ "query": "CreateCast ($file: Upload!) { createCast(file: $file) { id } }", "variables": { "file": null } }]' \
-F map='{ "0": ["0.variables.file"] }' \
-F 0=@my-file.pdf
```

Our [Node API Client](https://github.com/anvilco/node-anvil) uses multipart
uploads by default.
"""
scalar Upload

"""

An object used by `createEtchPacket` to specify a file. See the
[Etch e-sign guide](/docs/api/e-signatures) for more info.
"""
input EtchFile {
    base64File: Upload
    castEid: String
    fields: [JSON!]
    file: Upload
    "Filename set when creating the `EtchPacket`."
    filename: String
    fontSize: Int
    "An id string set when creating the `EtchPacket`."
    id: String!
    "For generated PDFs, set to false to disable the \"Generated at XXX\" timestamp at the bottom of the document."
    includeTimestamp: Boolean
    "For generated PDFs, you can specify a logo to be rendered at the top of the document."
    logo: JSON
    "Holds HTML/CSS to generate PDF"
    markup: JSON
    "Holds page customizations to generate PDF"
    page: JSON
    pageSizes: [JSON!]
    textColor: String
    title: String
}
